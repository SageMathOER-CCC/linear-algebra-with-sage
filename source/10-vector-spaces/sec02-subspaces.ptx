<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-subspaces"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Subspaces</title>
    <introduction xml:id="sm-introduction-subspaces">
        <p>
            A subspace of the vector space <m>V</m>
            is a nonempty subset <m>W</m> of <m>V</m>
            such that <m>W</m> is a vector space under
            the same addition and scalar multiplication as on <m>V</m>.
        </p>
        <p>
            For a nonempty subset <m>W</m> of a vector space <m>V</m>,
            to check that <m>W</m> is a subspace of <m>V</m>, 
            we need only verify that <m>W</m> satisfies the closure properties:
        </p>
        <dl>
            <li>
                <title>Addition</title>
                <p>
                    If <m>u, w \in W</m>, then <m>u + w \in W</m>.
                </p>
            </li>
            <li>
                <title>Scalar Multiplication</title>
                <p>
                    If <m>a \in \F</m> and <m>u \in W</m>, then
                    <m>a \cdot u \in W</m>.
                </p>
            </li>
        </dl>
        <p>
            Sage does not provide a way to check if a <em>subset</em> is a subspace. 
            The method <c>is_subspace</c> admits as argument a vector space <m>W</m>
            and check if it is subspace of the ambient space <m>V</m>. 
            In other words, it checks if <m>W</m> is a subset of <m>V</m>.
        </p>
        <sage>
            <input>
                V = VectorSpace(RR, 3)
                W = VectorSpace(RR, 2)
                W.is_subspace(V)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We obtained that <m>\R^2</m> is not a subspace of <m>\R^3</m>
            since it is not a subset.
        </p>
        <p>
            Next, we will explore a method for constructing a specific type
            of subspace within a given vector space.
        </p>
    </introduction>
    <subsection xml:id="subsec-spans">
        <title>Spans</title>
        <p>
            A linear combination of a set of vectors <m>\{v1,\dots, v_k\}</m>
            in a vector space <m>V</m> over the field <m>\mathbb F</m>
            is a vector of the form <m>a_1 v_1 + \dots +a_k v_k</m>,
            where <m>a_1,\dots ,a_k \in \mathbb F</m>.
        </p>
        <p>
            For example, let's calculate a linear combination of the vectors 
            <m>u</m> and <m>v</m> in <m>\R^3</m>:
        </p>
        <sage>
            <input>
                u = vector([0, 1/2, 0])
                v = vector([1, -2, 3])
                3*u + 2*v
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            The set of all linear combinations of a set of vectors
            <m>\{v_1,\dots, v_k\}</m> forms a subspace of <m>V</m>
            called the span of <m>\{v_1,\dots, v_k\}</m>,
            denoted <m>\operatorname{span}(\{v_1,\dots, v_k\})</m>.
        </p>
        <p>
            In Sage, the <c>span</c> command can be used to create the span of a set of vectors. 
            Let's find the span of the vectors <m>u</m> and <m>v</m> in <m>\R^3</m>.
        </p>
        <sage>
            <input>
                V = VectorSpace(RR, 3)

                S = V.span([u, v])
                S
            </input>
        </sage>
        <p>
            We can verify that <m>S</m> is a subspace of <m>\R^3</m>:
        </p>
        <sage>
            <input>
                S.is_subspace(V)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We can now check if other vectors lie within this span.
            For example, let's test if the vector <m>u = (2, 0, -2)</m>
            is in the span <m>S</m>.
        </p>
        <p>
            Observe that the subspace spanned by the set of vectors 
            <m>u, v</m> and <m>3u + 2v</m> is also <m>S</m>:
        </p>
        <sage>
            <input>
                V = VectorSpace(RR, 3)
                T = V.span([u, v, 3*u + 2*v])
                T
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We can now check for equality.
        </p>
        <sage>
            <input>
                T == S
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We see that the new vector added to the generators is redundant. 
            Next, we will see how Sage can detect this redundancy. 
        </p>
    </subsection>
    <subsection xml:id="subsec-linear-independence">
        <title>Linear Independence</title>
        <p>
        The vectors <m>v_1, v_2, \dots ,v_k</m> are <term>linearly dependent</term> if 
        there exist scalars <m>c_1, c_2,\dots , c_k \in \mathbb F</m>, 
        where at least one <m>c_i \neq 0</m>, such that
        </p>
        <md>
            <mrow> c_1 v_1 + c_2 v_2 + \dots + c_n v_k = 0 </mrow>
        </md>
        <p>
            Otherwise, we say these vectors are <term>linearly independent</term>.
        </p>
        <p>
            Sage provides the <c>linear_dependence</c> 
            method to check if a set of vectors is linearly dependent, 
            in a given vector space,
            and in that case outputs the coefficients 
            <m>c_1, c_2, \dots, c_k</m> of the linear combination.
        </p>
        <p>
            We can then test for linear dependence in the context of <m>V</m>.
        </p>
        <sage>
            <input>
                V = VectorSpace(RR, 3)
                v = vector([0, 1/2, 0])
                u = vector([1, -2, 3])
                w = vector([2, -5/2, 6])

                L = [v, u, w]
                V.linear_dependence(L)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We obtained a list of coefficients, 
            indicating that the vectors <m>u,v</m> and <m>w</m>
            are linearly dependent and the following combination gives the vector zero:
        </p>
        <md>
            <mrow> 1u + (2/3)v + (-1/3)w = 0 </mrow>
        </md>
        <p>
            Observe that the coefficients in the linear combination are not unique. 
            Sage assigns by default <m>1</m> as the first coefficient. 
        </p>
        <p>
            If the set of vectors is linearly independent, 
            then Sage returns an empty list:
        </p>
        <sage>
            <input>
                S = [u, v] 
                V.linear_dependence(S)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We can also check directly for linear independence:
        </p>
        <sage>
            <input>
                V.linear_dependence(S) == []
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            Alternatively, 
            we can manually check if a set of vectors is 
            linearly independent by using the matrix methods studied before.
        </p>
        <note>
            <title>Rank</title>
            <p>
                The rank of a matrix <m>M</m> is the maximal number of linearly independent
                row vectors (rows viewed as vectors). 
            </p>
        </note>
        <sage>
            <input>
                # Create a matrix from the vectors
                M = matrix([u,v,w])

                # Check if the rank is equal to the number of vectors
                M.rank() == len(M.rows())
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            The result is <c>True</c>, so the set <m>\{v_1, v_2, v_3\}</m> is linearly independent.
            Now let's consider a linearly dependent set.
        </p>
        <sage>
            <input>
                A = matrix([u, w])
                A = matrix([u1, u2, u3])
                A.rank() == len(A.rows())
            </input>
            <output>
                
            </output>
        </sage>
    </subsection>
    <subsection xml:id="subsec-basis-and-dimensions">
        <title>Basis and Dimensions</title>
        <p>
            A basis for the vector space <m>V</m>
            is a set of vectors <m>\{v_1, v_2,\dots ,v_k\}</m>
            that is linearly independent and spans <m>V</m>.
        </p>
        <p>
            Th <c>basis</c> method outputs a basis of the vector space,
            in echelonized form, as a list of vectors. 
        </p>
        <sage>
            <input>
                V = VectorSpace(QQ, 3)
                V.basis()
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            Sage implicitly computes the basis and dimension of any 
            subspace generated with the <c>span</c> command.
        </p>
        <sage>
            <input>
                V = VectorSpace(QQ, 4)
                # This set is linearly dependent
                v1 = vector(QQ, [1, 2,  0,  1])
                v2 = vector(QQ, [0, 2, -1,  2])
                v3 = vector(QQ, [1, 0,  1, -1])
                v4 = vector(QQ, [2, 4,  0,  2])
                S = V.span([v1,v2,v3,v4])
                S
            </input>
        </sage>
        <p>
            The method <c>basis_matrix</c> outputs a basis of the vector space, 
            in echelonized form, as rows of a matrix. 
        </p>
        <sage>
            <input>
                S.basis_matrix()
            </input>
        </sage>
        <p>
            The <c>dimension</c> command simply returns the number of vectors in the basis.
        </p>
        <sage>
            <input>
                S.dimension()
            </input>
        </sage>
    <p>
        Alternatively, 
        we can create the same subspace using the <c>subspace</c> method:
    </p>
    <sage>
        <input>
            W = V.subspace([v1,v2,v3,v4])
            W
        </input>
    </sage>
    <p>
        We can then verify that <m>W</m> is a subspace of <m>V</m> with the
        <c>is_subspace</c> method.
    </p>
    <sage>
        <input>
            W.is_subspace(V)
        </input>
    </sage>
    <p>
        We can check that we obtain the same object.
    </p>
    <sage>
        <input>
            S == W
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        We can also specify a different basis than the echelonized one given by default, 
        using the <c>subspace_with_basis</c> method:
    </p>
    <sage>
        <input>
            u1 = vector([1, 4, -1, 3]) #another basis of the same space S
            u2 = vector([2, 2, 1, 0])
            T = S.subspace_with_basis([u1,u2]) 
            T
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        This method returns error if we input a list that is not a basis for S.
    </p>
    <p>
        Observe that we still obtain the same object, 
        only the specified basis changes:
    </p>
    <sage>
        <input>
            S == W == T
        </input>
        <output>
            
        </output>
    </sage>
    </subsection>
    <subsection xml:id="subsec-extracting-a-basis-from-a-generator">
        <title>Extracting a Basis from a Generator</title>
        <p>
            Every spanning set in a vector space can be reduced to a basis of that vector space.
            We can manually extract a basis from a given generating set 
            <m>\{v_1, v_2, \dots ,v_n\}</m> as follows:
        </p>
        <ol marker="i">
            <li>
                <p>
                    Construct a matrix with <m>v_1, v_2, \dots ,v_n</m>
                    as its columns.
                </p>
            </li>
            <li>
                <p>
                    Find the pivot columns.
                </p>
            </li>
        </ol>
        <p>
            The columns corresponding to the pivots form a basis of the subspace spanned by the vectors.
        </p>
        <p>
            For example, let's extract a basis of <m>S</m> from the generator 
            <m>v_1,v_2,v_3,v_4</m>. 
        </p>
        <sage>
            <input>
                # Re-initialize our previous definitions
                V = VectorSpace(QQ, 4)
                v1 = vector(QQ, [1, 2,  0,  1])
                v2 = vector(QQ, [0, 2, -1,  2])
                v3 = vector(QQ, [1, 0,  1, -1])
                v4 = vector(QQ, [2, 4,  0,  2])

                A = column_matrix([v1,v2,v3,v4])
                A.pivots()
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We obtain that the pivot columns are the first and the second. 
            Then the vectors <m>v_1</m> and <m>v_2</m> forms a basis of <m>S</m>.
            Since we already know that the dimension of <m>S</m> is 2,
            this result is consistent. 
            We can also verify that these vectors are linearly independent:
        </p>
        <sage>
            <input>
                V.linear_dependence([v1,v2])
            </input>
            <output>
                
            </output>
        </sage>
    </subsection>
    <subsection xml:id="subsec-coordinates-in-a-basis">
        <title>Coordinates in a Basis</title>
        <p>
            If <m>B = \{b_1,b_2, \dots, b_n\}</m>
            is a basis of the vector space <m>V</m>, 
            then every <m>v \in V</m>
            can be expressed uniquely as a linear combination:
        </p>
        <md>
            <mrow>v = c_1 b_1 + c_2 b_2 + \dots + c_n b_n</mrow>
        </md>
        <p>
            The scalars <m>c_1, c_2, \dots, c_n</m>
            are the coordinates of <m>v</m> with respect to the basis <m>B</m>
            and we write <m>[v]_B = (c_1, c_2, \dots , c_n)</m>.
        </p>
        <p>
            Sage provides dedicated methods to calculate the coordinates of a given vector in any basis. 
            To calculate the coordinates in the canonical echelonized basis, 
            we simply use the method <c>coordinates</c>
            and Sage will return the coordinates as a list. 
            For instance, let's calculate the coordinates of <m>v_1</m>
            in the canonical basis <m>B</m> of <m>S</m>. 
            Recall that the canonical basis is given as a list:
        </p>
        <sage>
            <input>
                # Re-initialize our previous definitions
                v1 = vector(QQ, [1, 2,  0,  1])
                v2 = vector(QQ, [0, 2, -1,  2])
                v3 = vector(QQ, [1, 0,  1, -1])
                v4 = vector(QQ, [2, 4,  0,  2])
                S = V.span([v1,v2,v3,v4])
                u1 = vector([1, 4, -1, 3])
                u2 = vector([2, 2, 1, 0])

                B = S.basis()
                B
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            Then the coordinates of <m>v_1</m> are:
        </p>
        <sage>
            <input>
                S.coordinates(v1)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We obtained that the vector 
            <m>v_1 = b_1 + 2 \cdot b_2</m>.
        </p>
        <sage>
            <input>
                b1 = B[0] #first vector in the list B
                b2 = B[1] #second vector in the list B
                1*b1 + 2*b2 == v1
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            By using the method 
            <c>coordinate_vector</c> we obtain the same coordinates as a <c>vector</c>:
        </p>
        <sage>
            <input>
                v1B = S.coordinate_vector(v1)
                v1B
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            Recall the definition of matrix multiplication, 
            this results in <m>[v_1]_B \cdot M_B = v_1</m>, 
            where <m>M_B</m> is the canonical basis matrix of <m>S</m>.
        </p>
        ,<sage>
            <input>
                v1B * S.basis_matrix() == v1
            </input>
            <output>
                
            </output>
        </sage>
    </subsection>
    <subsection xml:id="subsec-change-of-basis">
        <title>Change of Basis</title>
        <p>
            To calculate the coordinates in any other user defined basis, 
            we use a combination of the methods <c>subspace_with_basis</c> and <c>coordinates</c>.
            For instance, let's calculate the coordinates of <m>v_1</m>
            in the basis <m>C = \{u_1,u_2\}</m> of <m>S</m>:
        </p>
        <sage>
            <input>
                # Re-initialize our previous definitions
                V = VectorSpace(QQ, 4)
                v1 = vector(QQ, [1, 2,  0,  1])
                v2 = vector(QQ, [0, 2, -1,  2])
                v3 = vector(QQ, [1, 0,  1, -1])
                v4 = vector(QQ, [2, 4,  0,  2])
                S = V.span([v1,v2,v3,v4])
                u1 = vector([1, 4, -1, 3])
                u2 = vector([2, 2, 1, 0])

                T = S.subspace_with_basis([u1,u2])
                T.coordinates(v1)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            We obtained that the vector <m>v_1 = 1/3 \cdot u_1 + 1/3 \cdot u_2</m>. 
            Once again, we can verify it by manually calculating this linear combination 
            and comparing it with the given vector:
        </p>
        <sage>
            <input>
                1/3*u1 + 1/3*u2 == v1
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            As expected, when we compute the coordinates of the basis vectors themselves, 
            we obtain the standard unit vector coordinates.
        </p>
        <sage>
            <input>
                S.subspace_with_basis([v1, v2]).coordinates(v1)
            </input>
            <output>
                
            </output>
        </sage>
        <sage>
            <input>
                S.subspace_with_basis([v1, v2]).coordinates(v2)
            </input>
            <output>
                
            </output>
        </sage>
    </subsection>
</section>
