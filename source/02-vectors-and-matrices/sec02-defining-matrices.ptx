<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-defining-matrices"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Matrices</title>

    <introduction xml:id="sm-introduction-matrices-in-sage">
        <p>
            <idx>
                <h>Matrices</h>
            </idx>
            In this section, we will see how to define matrices, and perform basic operations
            on them. A matrix is an <m>m \times n</m> rectangular array of numbers:
        </p>
        <p>
            <m>
                \begin{bmatrix}
                a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\
                a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\
                \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
                a_{m1} &amp; a_{m2} &amp; \dots &amp; a_{mn}
                \end{bmatrix}
            </m>
        </p>
        <p>
            where <m>m</m> is the number of rows and <m>n</m> is the number of columns. Each
            <em>entry</em> <m>a_{ij}, i=1\dots m, j=1\dots n,</m> corresponds to the value
            at the intersection of the <m>i</m>-th row and <m>j</m>-th column.
        </p>
        <p>
            Just like vectors, Sage does come with built-in support for matrices. There are
            many ways to define a matrix in Sage using the command <c>matrix</c>, passing for
            instance each of the rows of the matrix as a <em>list of numbers</em>.
        </p>
        <sage>
            <input>
                M = matrix([
                    [11, 13, 17, 19],
                    [23, 29, 31, 37],
                    [41, 43, 47, 53],
                ])

                M
            </input>
        </sage>

        <p>
            Or as a <em>list of vectors</em>.
        </p>
        <sage>
            <input>
                v1=vector([11, 13, 17, 19])
                v2=vector([23, 29, 31, 37])
                v3=vector([41, 43, 47, 53])

                M = matrix([v1, v2, v3])
                M
            </input>
        </sage>

        <p>
            Alternatively, we can create a matrix by passing the entries as a list, and
            the dimensions as arguments to the <c>matrix</c> command. Here is an example
            of a <m>2 \times 3</m> matrix.
        </p>
        <sage>
            <input>
                M = matrix(2, 3, [1, 1, 2, 3, 5, 8])
                M
            </input>
        </sage>
        <p>
            Note that in Sage, you can create a list consisting of repeated copies of the
            same element using the repetition operator <c>*</c>. For example, <c>[1] * 6</c>
            produces a list with six 1s, which is convenient when filling a matrix with
            identical entries like in the following example.
        </p>
        <sage>
            <input>
            matrix(2, 3, [1] * 6)
            </input>
        </sage>
        <p>
            We do not need to specify both dimensions of a matrix. Sage can infer the
            missing dimension from the number of entries in the list. Here is an example
            of a <m>5 \times 20</m> matrix containing the first <m>100</m> integers, where
            only the number of rows is specified.
        </p>
        <sage>
            <input>
                matrix(5, list(range(100)))
            </input>
        </sage>

        <p>
            The entries of the matrix can also be defined programmatically a list comprehension.
        </p>
        <sage>
            <input>
                M = matrix(2, 5, [j + i * 5 for i in range(2) for j in range(5)])
                M
            </input>
        </sage>

        <p>
            Sage also allows for constructing a larger matrix by combining smaller <em>submatrices</em> using
            the <c>block_matrix()</c> function (or <c>matrix.block()</c>). Submatrices can be arranged in
            rows and columns to form a single, larger matrix. Each row is entered as a list.
        </p>
        <p>
            Matrices of different dimensions can be used with the command <c>block_matrix</c> as long as
            the dimensions of the submatrices allow for their concatenation. In the following
            example, we create a <m>5 \times 5</m> matrix from four submatrices of different dimensions.
        </p>
        <sage>
            <input>
                A = matrix(2, 3, [1]*6)  # A 2x3 matrix filled with 1's
                B = matrix(2, 2, [2]*4)  # A 2x2 matrix filled with 2's
                C = matrix(3, 3, [3]*9)  # A 3x3 matrix filled with 3's
                D = matrix(3, 2, [4]*6)  # A 3x2 matrix filled with 4's

                M = block_matrix([
                    [A, B],
                    [C, D]
                ])
                M
            </input>
        </sage>
        <p>
            To simplify the following commands, let's use a <m>2 \times 3</m> matrix <m>M</m> 
            where each element is a unique value.
        </p>
        <sage>
            <input>
                M = matrix(2,3, [0,1,2,3,4,5])
                M
            </input>
        </sage>
        
        <p>
            <idx>
                <h>Matrices</h>
                <h>indexing</h>
            </idx>
            The individual entries of a matrix can be accessed using the row and column indices. Since
            indices in Sage start at 0, to retrieve the entry <m>a_{ij}</m> in a matrix <m>M</m>, we type
            <c>M[i-1, j-1]</c>. Here is, for instance, how we can retrieve the entry at the second row
            and third column of the matrix <m>M</m>.
        </p>
        <sage>
            <input>
                a_23 = M[1, 2]
                a_23
            </input>
        </sage>

        <p>
            Sage provides dedicated methods to retrieve all rows of the matrix, or all its columns.
            It also support the retrieval of the diagonal elements of a matrix, or extracting a
            specific row or a specific column of a given matrix.
        </p>

        <p>
            <idx>
                <h>Matrices</h>
                <h>rows</h>
            </idx>
            The <c>rows</c> method returns all rows of the matrix (as a list of tuples).
        </p>
        <sage>
            <input>
                M.rows()
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>columns</h>
            </idx>
            In the same way, the <c>columns</c> method returns all the columns of the matrix
            (as a list of tuples).
        </p>
        <sage>
            <input>
                M.columns()
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>row</h>
            </idx>
            The <c>M.row(i-1)</c> returns the <m>i</m>-th row of the matrix.
        </p>
        <sage>
            <input>
                M.row(1)     # 2nd row
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>column</h>
            </idx>
            The <c>M.column(j-1)</c> returns the <m>j</m>-th column of the matrix.
        </p>
        <sage>
            <input>
                M.column(2)  # 3rd column
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>diagonal</h>
            </idx>
            The <c>M.diagonal()</c> returns the main diagonal of the matrix.
        </p>
        <sage>
            <input>
                M.diagonal()
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>nrows</h>
            </idx>
            Similarly, Sage offers more methods to help us iterate over the rows or the
            columns of a matrix. For instance, the method <c>nrows()</c> returns the number
            of rows of a matrix.
        </p>
        <sage>
            <input>
                M.nrows()
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>ncols</h>
            </idx>
            Sage method <c>ncols()</c> returns the number of rows of the matrix.
        </p>
        <sage>
            <input>
                M.ncols()
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>dimensions</h>
            </idx>
            Alternatively, the method <c>dimensions</c> returns the dimension of the matrix
            as a pair <c>(nrows, ncols)</c>.
        </p>
        <sage>
            <input>
                M.dimensions()
            </input>
        </sage>

        <p>
            Sage defines the method <c>is_square()</c> that returns <c>True</c> if the matrix is square. 
            In this case, it returns <c>False</c> because matrix <m>M</m> is a <m>2 \times 3</m> matrix.
        </p>
        <sage>
            <input>
                M.is_square()
            </input>
        </sage>

        <p>
            To extract a <em>submatrix</em> from a matrix given the range of rows and columns
            to include, Sage command <c>matrix_from_rows_and_columns()</c> takes two lists: the
            first for row indices, and the second for column indices as in the following example.
        </p>
        <sage>
            <input>
                A = matrix([[1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]])

                A.matrix_from_rows_and_columns([0, 1], [1, 2])
            </input>
        </sage>
        <p>
            The resulting submatrix from the previous command contains the entries at
            the intersection of the indexed rows (i.e. first and second rows) and the
            indexed columns (i.e. the second and third columns).
        </p>
        <p>
            Note that the order of the indices in the lists matters and will affect the
            order of the rows and columns in the resulting submatrix. In the following
            example, the order of the columns in the resulting submatrix is different
            from the previous example.
        </p>
        <sage>
            <input>
                A.matrix_from_rows_and_columns([0, 1], [2, 1])
            </input>
        </sage>
        <p>
            An alternative, and perhaps more straightforward way to achieve the same result
            is to use Python-like slicing and explicitly listing the range of interest as in
            the following example.
        </p>
        <sage>
            <input>
                A[0:2, 1:3]
            </input>
        </sage>
        <p>
            The syntax <c>A[i:j, k:l]</c> extracts the submatrix from rows <m>i</m> to <m>j-1</m>
            and columns <m>k</m> to <m>l-1</m> (lower bound inclusive but not the upper bound of the range).
        </p>
        <p>
            Note that a matrix with a single list of values creates a <em>vector-like</em>
            object, but it is NOT a vector. Here is a vector in Sage.
        </p>
        <sage>
            <input>
                v=vector([1, 2, 3])
                v
            </input>
        </sage>
        <p>
            Compare that to this single-row matrix. Observe the square brackets in matrices
            in lieu of the parenthesis.
        </p>
        <sage>
            <input>
                m=matrix([1, 2, 3])
                m
            </input>
        </sage>

        <p>
            <em>Type assertion</em> is a useful tool to check if two objects are <em>identical</em>
            and are of the same type. For instance, comparing the types of <m>v</m> and <m>m</m>
            yields <c>False</c> because they are <em>NOT</em> of the same type.
        </p>
        <sage>
            <input>
                v==m
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>Base Rings</h>
            </idx>
            Just like vectors, matrices in Sage can also be created in different <em>Base Rings</em>,
            inferred from the datatype passed to the <c>matrix</c> command, or explicitly when
            instantiating the matrix.
        </p>
        <sage>
            <input>
                m_int = matrix(ZZ, 3, list(range(15)))
                m_int
            </input>
        </sage>

        <p>
            <idx>
                <h>Matrices</h>
                <h>Ring</h>
            </idx>
            The method <c>base_ring</c> returns the <em>base ring</em> of the matrix.
        </p>
        <sage>
            <input>
                m_int.base_ring()
            </input>
        </sage>

        <p>
            Once again, if the ring is omitted, Sage will simply infer the ring from
            the datatype of the matrix entries. Sage matrices supports the same rings
            as vectors (<m>ZZ, QQ, RR, CC</m>).
        </p>
    </introduction>
</section>
