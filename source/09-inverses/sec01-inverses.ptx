<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-inverse-matrix" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Inverse Matrix</title>
    <p>
        Let <m>A</m> be a square matrix.
        A matrix <m>B</m> is called an inverse of <m>A</m> if <m>AB = I</m> and <m>BA = I</m>, 
        where <m>I</m> is the identity matrix.
    </p>
    <p>
        If such a matrix exists, we say that <m>A</m> is invertible and we denote the inverse by <m>A^{-1}</m>.
    </p>
    <p>
        We can ask Sage whether a matrix is invertible using the <c>is_invertible()</c> method:
    </p>
    <sage>
        <input>
            A = matrix([      # case i
                    [0, 1, -1],
                    [1, 2, 0],
                    [1, 0, 1]
                ])
            A.is_invertible()
        </input>
    </sage>
    <p>
        In Sage, if a matrix is invertible, the inverse of a matrix can be computed using the <c>inverse()</c> method:
    </p>
    <sage>
    <input>
        A.inverse()
    </input>
    </sage>
    <p>
        We can check that the products of these matrices are actually the identity:
    </p>
    <sage>
        <input>
            A * A.inverse()
        </input>
    </sage>
    <sage>
        <input>
            A.inverse() * A
        </input>
    </sage>
    <p>
        Exponent notation also produces the same result.
    </p>
    <sage>
        <input>
            A^-1
        </input>
    </sage>
    <p>
        Observe that a matrix is invertible over its base ring.
        Even though the next matrix is invertible,
        we would obtain a false result if we do not specify the ring:
    </p>
    <sage>
        <input>
            A = matrix([
                [1, 2, 8],
                [9, 8, 9],
                [5, 6, 0]
            ])
            A.is_invertible()
        </input>
    </sage>
    <p>
        By calculating the inverse,
        we can see that the inverse exists and therefore <m>A</m> is invertible,
        though the coefficients are not integers:
    </p>
    <sage>
        <input>
            A^-1
        </input>
    </sage>
    <p>
        If we specify the ring to be the rationals, we obtain the correct result:
    </p>
    <sage>
        <input>
            A = matrix(QQ, [
                [1, 2, 8],
                [9, 8, 9],
                [5, 6, 0]
            ])
            A.is_invertible()
        </input>
    </sage>
    <p>
        Next, we will show how to use Sage to implement the different ways in which we can calculate the inverse matrix.
    </p>
    <subsection xml:id="subsec-echelon-method">
        <title>Echelon Method</title>
        <p>
            A matrix is invertible if and only if the reduced row echelon form is the identity matrix.
            We can find the inverse matrix of <m>A</m> by augmenting <m>A</m> by the identity matrix <m>I</m> and then finding the reduced row echelon form.
            If the matrix is invertible,
            the first half of the matrix would be the identity and the second half the inverse matrix.
        </p>
        <p>
            Let's start by augmenting the matrix.
        </p>
        <sage>
            <input>
                A = matrix([      # case i
                        [0, 1, -1],
                        [1, 2, 0],
                        [1, 0, 1]
                    ])
                AI = A.augment(identity_matrix(3), subdivide=true)
                AI
            </input>
        </sage>
        <p>
            By invoking <c>rref()</c>, we obtain the reduced form of the augmented matrix, which allows us to determine whether the original matrix is invertible.
        </p>
        <sage>
            <input>
                rrefAI = AI.rref()
                rrefAI
            </input>
        </sage>
        <p>
            Since the left sub-matrix is the identity matrix, 
            the original matrix is invertible and the right sub-matrix is the inverse.
            We can obtain the inverse using the <c>submatrix()</c> method:
        </p>
        <sage>
            <input>
                B = rrefAI.submatrix(0,3)
                B
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            This algorithm coincides with Sage's built-in <c>inverse()</c> method:
        </p>
        <sage>
            <input>
                A.inverse() == B 
            </input>
        </sage>
    </subsection>
    <subsection xml:id="subsec-minors-cofactors-and-adjugate-for-inverse">
        <title>Adjugate Method</title>
        <p>
            The adjugate matrix can be used to compute the inverse of an invertible matrix using the formula:
            <m>A^{-1} = \frac{1}{\det(A)} \cdot \text{adj}(A)</m>.
        </p>
        <sage>
            <input>
                C = A.adjugate() / A.det()
                C
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            This algorithm also coincides with Sage's built-in <c>inverse()</c> method:
        </p>
        <sage>
            <input>
                A.inverse() == C
            </input>
        </sage>
    </subsection>
    <subsection xml:id="subsec-comparing-methods">
        <title>Comparing Methods</title>
        <p>
            The three methods coincide when the matrix is invertible.
        </p>
        <sage>
            <input>
                I = identity_matrix(3)
                A = matrix([      # case i
                        [0, 1, -1],
                        [1, 2, 0],
                        [1, 0, 1]
                    ])
                A.inverse() == A.augment(I).rref().submatrix(0,3) == A.adjugate() / A.det()
            </input>
        </sage>
        <p>
            Let's see how they differ in the way they handled non-invertible matrices.
        </p>
        <p>
            In the case of a matrix that is not invertible, the <c>inverse()</c> method will raise an exception.
        </p>
        <sage>
            <input>
                M = matrix([   # case ii
                    [1, 2, 0],
                    [0, 1, -1],
                    [1, 0, 2]
                ])
                try:
                    M.inverse()
                except Exception as e:
                    print(e)
            </input>
        </sage>
        <p>
            Using the adjugate method will also raise an exception.
        </p>
        <sage>
            <input>
                try:
                    M.inverse() == M.adjugate() / M.det()
                except Exception as e:
                    print(e)
            </input>
        </sage>
        <p>
            While the echelon method will return a matrix whose first half is not the identity.
        </p>
        <sage>
            <input>
                M.augment(I).rref()
            </input>
        </sage>
        <p>
            We can programmatically check for this with the following code:
        </p>
        <sage>
            <input>
                I == M.augment(I).rref().submatrix(0,0,-1,3)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            To generalize the previous code to any <m>n \times n</m> matrix, 
            keep the first three arguments the same but replace 3 with <m>n</m>.
        </p>
    </subsection>
</section>
