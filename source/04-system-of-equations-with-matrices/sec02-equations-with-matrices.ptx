<section xml:id="sec-equations-with-Matrices" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Systems of Equations with Matrices</title>
    <p>
        As an introduction to solving equations in Sage, we worked with equations symbolically. Now, we will learn how to solve systems of equations with vectors and matrices.
    </p>
    <p>
        Let's solve the following system of equations:
    </p>
    <md>
        <mrow>
            \begin{array}{c}
            x + 2y + z  = 4\\
            0x + y - z  = 0\\
            x + 0y + 2z = 4
            \end{array}
        </mrow>
    </md>
    <p>
        In Sage, we can create an coefficient matrix using the <c>matrix</c> function.
    </p>
    <sage>
        <input>
            A = matrix([
                    [1, 2, 0],
                    [0, 1, -1],
                    [1, 0, 2]
                ])
            print(A)
        </input>
        <output>

        </output>
    </sage>
    <p>
        Next, provide a list of constants to the <c>vector</c> function.
    </p>
    <sage>
        <input>
            b = vector([4, 0, 4])
            print(b)
        </input>
        <output>

        </output>
    </sage>
    <p>
        Finally, call the <c>solve_right</c> method on the matrix and pass the solution vector as its argument.
    </p>
    <sage>
        <input>
            A.solve_right(b)
        </input>
        <output>

        </output>
    </sage>
    <p>
        The output <c>(4, 0, 0)</c> expresses one solution to the system:
    </p>
    <md>
        <mrow> x = 4, \; y = 0, \; z = 0 </mrow>
    </md>
    <section xml:id="sec-differences-in-solutions">
        <title>Differences in Solutions</title>
    <p>
        To find all solutions we first need to augment matrix <m>A</m> with vector <m>b</m>. This is done with the <c>augment</c> method.
    </p>
    <sage>
        <input>
            # subdivide=True adds a dividing line to the new matrix
            Ab = A.augment(b, subdivide=True)
            Ab
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        To solve this new matrix, call the <c>rref</c> method to output the matrix in reduced row echelon form.
    </p>
    <sage>
        <input>
            Ab.rref()
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        The row of zeros at the bottom indicates that the system has infinitely many solutions.
    </p>
    <p>
        These methods also differ in how they handle a system with no solutions. For example if we instead solve for a vector <m>v = (1,2,8)</m> with the <c>solve_right</c> method, an error will be thrown.
    </p>
    <sage>
        <input>
            v = vector([1,2,8])
            try:
                A.solve_right(v)
            except Exception as e:
                print(e)
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        Where as the <c>rref</c> method will return a matrix which represents an inconsistent system.
    </p>
    <sage>
        <input>
            A.augment(v, subdivide=True).rref()
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        The two methods differ very little when there is only one solution.
        The <c>solve_right</c> method is efficient when the system has a unique solution.
    </p>
    <sage>
        <input>
            M = matrix([
                    [1, 2, 3], 
                    [2, -3, 2], 
                    [3, 1, -1]
                ])
            u = vector([6, 14, -2])
            M.solve_right(u)
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            Mu = M.augment(u)
            Mu.rref()
        </input>
        <output>
            
        </output>
    </sage>
    </section>
</section>
