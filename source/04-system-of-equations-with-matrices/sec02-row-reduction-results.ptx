<section xml:id="sec-row-reduction-results" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Row Reduction Results</title>
    <p>
        As an introduction to solving equations in Sage, we worked with equations symbolically. Now, we will learn how to solve systems of equations with vectors and matrices.
    </p>
    <p>
        Let's solve <m>\textbf{Case II}</m> again:
    </p>
    <md>
        <mrow>
            \begin{array}{c}
            y - z = 0\\
            x + 2y = 4\\
            x + z = 4
            \end{array}
        </mrow>
    </md>
    <p>
        In Sage, we can create an coefficient matrix using the <c>matrix</c> function.
    </p>
    <sage>
        <input>
            M = matrix([
                    [1, 2, 0],
                    [0, 1, -1],
                    [1, 0, 2]
                ])
            M
        </input>
        <output>

        </output>
    </sage>
    <p>
        Next, provide a list of constants to the <c>vector</c> function.
    </p>
    <sage>
        <input>
            u = vector([4, 0, 4])
            u 
        </input>
        <output>

        </output>
    </sage>
    <p>
        Finally, call the <c>solve_right()</c> method on the matrix and pass the solution vector as its argument.
    </p>
    <sage>
        <input>
            M.solve_right(u)
        </input>
        <output>

        </output>
    </sage>
    <p>
        The output <c>(4, 0, 0)</c> expresses one solution to the system:
    </p>
    <md>
    <mrow>
        \begin{array}{c}
        x = 4\\
        y = 0\\
        z = 0
        \end{array}
    </mrow>
    </md>
    <section xml:id="sec-differences-in-solutions">
        <title>Differences in Solutions</title>
    <p>
        To find all solutions we first need to augment matrix <m>M</m> with vector <m>b</m>. 
        This is done with the <c>augment()</c> method.
    </p>
    <sage>
        <input>
            # subdivide=True adds a dividing line to the new matrix
            Mu = M.augment(u, subdivide=True)
            Mu 
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        To solve this new matrix, call the <c>rref()</c> method to output the matrix in reduced row echelon form.
    </p>
    <sage>
        <input>
            Mu.rref()
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        The row of zeros at the bottom indicates that the system has infinitely many solutions.
    </p>
    <p>
        These methods also differ in how they handle a system with no solutions. 
        For example we will pass <m>\textbf{Case III}</m> to the <c>solve_right()</c> method, 
        and an error will be thrown.
    </p>
    <sage>
        <input>
            T = matrix([
                [1, 2, 0],
                [1, 2, 0],
                [1, 0, 2]
            ])
            v = vector([4, 1, 4])
            try:
                T.solve_right(v)
            except Exception as e:
                print(e)
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        Where as the <c>rref()</c> method will return a matrix which represents an inconsistent system.
    </p>
    <sage>
        <input>
            T.augment(v, subdivide=True).rref()
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        The two methods differ very little when there is only one solution, 
        like with <m>\textbf{Case I}</m> bellow.
        The <c>solve_right()</c> method is efficient when the system has a unique solution.
    </p>
    <sage>
        <input>
            A = matrix([
                [0, 1, -1],
                [1, 2, 0],
                [1, 0, 1]
            ])
            b = vector([0, 4, 4])
            A.solve_right(b)
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            Ab = A.augment(b)
            Ab.rref()
        </input>
        <output>
            
        </output>
    </sage>
    </section>
</section>
